{"ast":null,"code":"/**\n * Utility functions for handling audio recording and playback\n */\n\n/**\n * Requests microphone access and returns a MediaStream\n */\nexport const getMicrophoneAccess = async () => {\n  try {\n    return await navigator.mediaDevices.getUserMedia({\n      audio: true\n    });\n  } catch (error) {\n    console.error('Error accessing microphone:', error);\n    throw new Error('Could not access microphone. Please ensure you have granted microphone permissions.');\n  }\n};\n\n/**\n * Creates an audio context and analyzer node for visualization\n */\nexport const createAudioContext = stream => {\n  const AudioContext = window.AudioContext || window.webkitAudioContext;\n  const audioContext = new AudioContext();\n  const source = audioContext.createMediaStreamSource(stream);\n  const analyser = audioContext.createAnalyser();\n  analyser.fftSize = 256;\n  source.connect(analyser);\n  return {\n    audioContext,\n    analyser\n  };\n};\n\n/**\n * Records audio from the microphone and returns the audio blob\n */\nexport const recordAudio = (stream, duration = 60000) => {\n  return new Promise((resolve, reject) => {\n    const mediaRecorder = new MediaRecorder(stream);\n    const audioChunks = [];\n    mediaRecorder.ondataavailable = event => {\n      if (event.data.size > 0) {\n        audioChunks.push(event.data);\n      }\n    };\n    mediaRecorder.onstop = () => {\n      const audioBlob = new Blob(audioChunks, {\n        type: 'audio/wav'\n      });\n      resolve(audioBlob);\n    };\n    mediaRecorder.onerror = event => {\n      console.error('MediaRecorder error:', event);\n      reject(new Error('Error recording audio'));\n    };\n\n    // Start recording\n    mediaRecorder.start();\n\n    // Auto-stop after duration (default 1 minute)\n    setTimeout(() => {\n      if (mediaRecorder.state !== 'inactive') {\n        mediaRecorder.stop();\n      }\n    }, duration);\n  });\n};\n\n/**\n * Plays an audio blob\n */\nexport const playAudio = audioBlob => {\n  const audioUrl = URL.createObjectURL(audioBlob);\n  const audio = new Audio(audioUrl);\n  audio.play().catch(error => {\n    console.error('Error playing audio:', error);\n  });\n};\n\n/**\n * Formats duration in seconds to MM:SS format\n */\nexport const formatDuration = seconds => {\n  const mins = Math.floor(seconds / 60);\n  const secs = Math.floor(seconds % 60);\n  return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;\n};\n\n/**\n * Converts a Blob to a base64 string\n */\nexport const blobToBase64 = blob => {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onloadend = () => {\n      const base64String = reader.result.split(',')[1];\n      resolve(base64String);\n    };\n    reader.onerror = reject;\n    reader.readAsDataURL(blob);\n  });\n};\n\n/**\n * Checks if the browser supports the Web Audio API\n */\nexport const isAudioAPISupported = () => {\n  return !!(window.AudioContext || window.webkitAudioContext);\n};\n\n/**\n * Checks if the browser supports the MediaRecorder API\n */\nexport const isMediaRecorderSupported = () => {\n  return typeof MediaRecorder !== 'undefined' && MediaRecorder.isTypeSupported('audio/webm');\n};\n\n/**\n * Gets the MIME type for audio recording based on browser support\n */\nexport const getSupportedMimeType = () => {\n  const types = ['audio/webm;codecs=opus', 'audio/ogg;codecs=opus', 'audio/webm', 'audio/ogg', 'audio/wav'];\n  return types.find(type => MediaRecorder.isTypeSupported(type));\n};","map":{"version":3,"names":["getMicrophoneAccess","navigator","mediaDevices","getUserMedia","audio","error","console","Error","createAudioContext","stream","AudioContext","window","webkitAudioContext","audioContext","source","createMediaStreamSource","analyser","createAnalyser","fftSize","connect","recordAudio","duration","Promise","resolve","reject","mediaRecorder","MediaRecorder","audioChunks","ondataavailable","event","data","size","push","onstop","audioBlob","Blob","type","onerror","start","setTimeout","state","stop","playAudio","audioUrl","URL","createObjectURL","Audio","play","catch","formatDuration","seconds","mins","Math","floor","secs","toString","padStart","blobToBase64","blob","reader","FileReader","onloadend","base64String","result","split","readAsDataURL","isAudioAPISupported","isMediaRecorderSupported","isTypeSupported","getSupportedMimeType","types","find"],"sources":["/Users/ganesharihanth/Desktop/App/doctor-patient-chat/client/src/utils/audioUtils.ts"],"sourcesContent":["/**\n * Utility functions for handling audio recording and playback\n */\n\n/**\n * Requests microphone access and returns a MediaStream\n */\nexport const getMicrophoneAccess = async (): Promise<MediaStream> => {\n  try {\n    return await navigator.mediaDevices.getUserMedia({ audio: true });\n  } catch (error) {\n    console.error('Error accessing microphone:', error);\n    throw new Error('Could not access microphone. Please ensure you have granted microphone permissions.');\n  }\n};\n\n/**\n * Creates an audio context and analyzer node for visualization\n */\nexport const createAudioContext = (stream: MediaStream) => {\n  const AudioContext = window.AudioContext || (window as any).webkitAudioContext;\n  const audioContext = new AudioContext();\n  const source = audioContext.createMediaStreamSource(stream);\n  const analyser = audioContext.createAnalyser();\n  analyser.fftSize = 256;\n  source.connect(analyser);\n  return { audioContext, analyser };\n};\n\n/**\n * Records audio from the microphone and returns the audio blob\n */\nexport const recordAudio = (stream: MediaStream, duration: number = 60000): Promise<Blob> => {\n  return new Promise((resolve, reject) => {\n    const mediaRecorder = new MediaRecorder(stream);\n    const audioChunks: BlobPart[] = [];\n\n    mediaRecorder.ondataavailable = (event) => {\n      if (event.data.size > 0) {\n        audioChunks.push(event.data);\n      }\n    };\n\n    mediaRecorder.onstop = () => {\n      const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });\n      resolve(audioBlob);\n    };\n\n    mediaRecorder.onerror = (event) => {\n      console.error('MediaRecorder error:', event);\n      reject(new Error('Error recording audio'));\n    };\n\n    // Start recording\n    mediaRecorder.start();\n\n    // Auto-stop after duration (default 1 minute)\n    setTimeout(() => {\n      if (mediaRecorder.state !== 'inactive') {\n        mediaRecorder.stop();\n      }\n    }, duration);\n  });\n};\n\n/**\n * Plays an audio blob\n */\nexport const playAudio = (audioBlob: Blob): void => {\n  const audioUrl = URL.createObjectURL(audioBlob);\n  const audio = new Audio(audioUrl);\n  audio.play().catch(error => {\n    console.error('Error playing audio:', error);\n  });\n};\n\n/**\n * Formats duration in seconds to MM:SS format\n */\nexport const formatDuration = (seconds: number): string => {\n  const mins = Math.floor(seconds / 60);\n  const secs = Math.floor(seconds % 60);\n  return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;\n};\n\n/**\n * Converts a Blob to a base64 string\n */\nexport const blobToBase64 = (blob: Blob): Promise<string> => {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onloadend = () => {\n      const base64String = (reader.result as string).split(',')[1];\n      resolve(base64String);\n    };\n    reader.onerror = reject;\n    reader.readAsDataURL(blob);\n  });\n};\n\n/**\n * Checks if the browser supports the Web Audio API\n */\nexport const isAudioAPISupported = (): boolean => {\n  return !!(window.AudioContext || (window as any).webkitAudioContext);\n};\n\n/**\n * Checks if the browser supports the MediaRecorder API\n */\nexport const isMediaRecorderSupported = (): boolean => {\n  return typeof MediaRecorder !== 'undefined' && MediaRecorder.isTypeSupported('audio/webm');\n};\n\n/**\n * Gets the MIME type for audio recording based on browser support\n */\nexport const getSupportedMimeType = (): string | undefined => {\n  const types = [\n    'audio/webm;codecs=opus',\n    'audio/ogg;codecs=opus',\n    'audio/webm',\n    'audio/ogg',\n    'audio/wav',\n  ];\n  \n  return types.find(type => MediaRecorder.isTypeSupported(type));\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}