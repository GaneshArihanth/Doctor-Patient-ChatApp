{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useRef, useEffect, useCallback } from 'react';\nimport { getMicrophoneAccess, createAudioContext, formatDuration } from '../utils/audioUtils.ts';\nconst useAudioRecorder = ({\n  onRecordingComplete,\n  maxDuration = 60000 // 1 minute default\n} = {}) => {\n  _s();\n  const [state, setState] = useState({\n    isRecording: false,\n    duration: 0,\n    error: null,\n    audioBlob: null,\n    audioUrl: null\n  });\n  const mediaRecorderRef = useRef(null);\n  const streamRef = useRef(null);\n  const timerRef = useRef(null);\n  const startTimeRef = useRef(0);\n  const audioContextRef = useRef(null);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      stopRecording();\n      if (audioContextRef.current) {\n        audioContextRef.current.audioContext.close();\n      }\n      if (streamRef.current) {\n        streamRef.current.getTracks().forEach(track => track.stop());\n      }\n    };\n  }, []);\n\n  // Update duration while recording\n  useEffect(() => {\n    if (!state.isRecording) return;\n    const updateDuration = () => {\n      const currentTime = Date.now();\n      const duration = Math.floor((currentTime - startTimeRef.current) / 1000);\n      setState(prev => ({\n        ...prev,\n        duration\n      }));\n      if (duration * 1000 >= maxDuration) {\n        stopRecording();\n      } else {\n        timerRef.current = window.setTimeout(updateDuration, 100);\n      }\n    };\n    timerRef.current = window.setTimeout(updateDuration, 100);\n    return () => {\n      if (timerRef.current) {\n        clearTimeout(timerRef.current);\n      }\n    };\n  }, [state.isRecording, maxDuration]);\n  const startRecording = useCallback(async () => {\n    try {\n      // Reset state\n      setState({\n        isRecording: false,\n        duration: 0,\n        error: null,\n        audioBlob: null,\n        audioUrl: null\n      });\n\n      // Get microphone access\n      const stream = await getMicrophoneAccess();\n      streamRef.current = stream;\n\n      // Set up audio context for visualization\n      audioContextRef.current = createAudioContext(stream);\n\n      // Create media recorder\n      const mediaRecorder = new MediaRecorder(stream);\n      mediaRecorderRef.current = mediaRecorder;\n      const audioChunks = [];\n      mediaRecorder.ondataavailable = event => {\n        if (event.data.size > 0) {\n          audioChunks.push(event.data);\n        }\n      };\n      mediaRecorder.onstop = () => {\n        const audioBlob = new Blob(audioChunks, {\n          type: 'audio/wav'\n        });\n        const audioUrl = URL.createObjectURL(audioBlob);\n        setState(prev => ({\n          ...prev,\n          audioBlob,\n          audioUrl,\n          isRecording: false\n        }));\n        if (onRecordingComplete) {\n          onRecordingComplete(audioBlob);\n        }\n      };\n      mediaRecorder.onerror = event => {\n        console.error('MediaRecorder error:', event);\n        setState(prev => ({\n          ...prev,\n          error: 'Error recording audio',\n          isRecording: false\n        }));\n      };\n\n      // Start recording\n      mediaRecorder.start();\n      startTimeRef.current = Date.now();\n      setState(prev => ({\n        ...prev,\n        isRecording: true,\n        duration: 0,\n        error: null\n      }));\n    } catch (error) {\n      console.error('Error starting recording:', error);\n      setState(prev => ({\n        ...prev,\n        error: error instanceof Error ? error.message : 'Failed to start recording',\n        isRecording: false\n      }));\n    }\n  }, [onRecordingComplete]);\n  const stopRecording = useCallback(() => {\n    if (mediaRecorderRef.current && state.isRecording) {\n      mediaRecorderRef.current.stop();\n\n      // Stop all tracks in the stream\n      if (streamRef.current) {\n        streamRef.current.getTracks().forEach(track => track.stop());\n        streamRef.current = null;\n      }\n\n      // Close audio context\n      if (audioContextRef.current) {\n        audioContextRef.current.audioContext.close();\n        audioContextRef.current = null;\n      }\n    }\n    if (timerRef.current) {\n      clearTimeout(timerRef.current);\n      timerRef.current = null;\n    }\n  }, [state.isRecording]);\n  const reset = useCallback(() => {\n    stopRecording();\n    setState({\n      isRecording: false,\n      duration: 0,\n      error: null,\n      audioBlob: null,\n      audioUrl: null\n    });\n  }, [stopRecording]);\n  const getAnalyserData = useCallback(() => {\n    if (!audioContextRef.current) return null;\n    const {\n      analyser\n    } = audioContextRef.current;\n    const dataArray = new Uint8Array(analyser.frequencyBinCount);\n    analyser.getByteFrequencyData(dataArray);\n    return {\n      data: Array.from(dataArray),\n      getFrequencyValue: (minHz, maxHz) => {\n        var _audioContextRef$curr;\n        const sampleRate = ((_audioContextRef$curr = audioContextRef.current) === null || _audioContextRef$curr === void 0 ? void 0 : _audioContextRef$curr.audioContext.sampleRate) || 44100;\n        const minIndex = Math.round(minHz / (sampleRate / 2) * dataArray.length);\n        const maxIndex = Math.round(maxHz / (sampleRate / 2) * dataArray.length);\n        let sum = 0;\n        let count = 0;\n        for (let i = minIndex; i <= maxIndex && i < dataArray.length; i++) {\n          sum += dataArray[i];\n          count++;\n        }\n        return count > 0 ? sum / count : 0;\n      },\n      getVolume: () => {\n        let sum = 0;\n        dataArray.forEach(value => {\n          sum += value * value;\n        });\n        return Math.sqrt(sum / dataArray.length) / 255; // Normalize to 0-1\n      }\n    };\n  }, []);\n  return {\n    // State\n    isRecording: state.isRecording,\n    duration: state.duration,\n    formattedDuration: formatDuration(state.duration),\n    error: state.error,\n    audioBlob: state.audioBlob,\n    audioUrl: state.audioUrl,\n    // Methods\n    startRecording,\n    stopRecording,\n    reset,\n    getAnalyserData\n  };\n};\n_s(useAudioRecorder, \"pBKiI1LJRzxEwXFD3DBEh80a+ns=\");\nexport default useAudioRecorder;","map":{"version":3,"names":["useState","useRef","useEffect","useCallback","getMicrophoneAccess","createAudioContext","formatDuration","useAudioRecorder","onRecordingComplete","maxDuration","_s","state","setState","isRecording","duration","error","audioBlob","audioUrl","mediaRecorderRef","streamRef","timerRef","startTimeRef","audioContextRef","stopRecording","current","audioContext","close","getTracks","forEach","track","stop","updateDuration","currentTime","Date","now","Math","floor","prev","window","setTimeout","clearTimeout","startRecording","stream","mediaRecorder","MediaRecorder","audioChunks","ondataavailable","event","data","size","push","onstop","Blob","type","URL","createObjectURL","onerror","console","start","Error","message","reset","getAnalyserData","analyser","dataArray","Uint8Array","frequencyBinCount","getByteFrequencyData","Array","from","getFrequencyValue","minHz","maxHz","_audioContextRef$curr","sampleRate","minIndex","round","length","maxIndex","sum","count","i","getVolume","value","sqrt","formattedDuration"],"sources":["/Users/ganesharihanth/Desktop/App/doctor-patient-chat/client/src/hooks/useAudioRecorder.ts"],"sourcesContent":["import { useState, useRef, useEffect, useCallback } from 'react';\nimport { \n  getMicrophoneAccess, \n  recordAudio, \n  createAudioContext,\n  formatDuration\n} from '../utils/audioUtils.ts';\n\ninterface UseAudioRecorderProps {\n  onRecordingComplete?: (audioBlob: Blob) => void;\n  maxDuration?: number; // in milliseconds\n}\n\ninterface RecordingState {\n  isRecording: boolean;\n  duration: number;\n  error: string | null;\n  audioBlob: Blob | null;\n  audioUrl: string | null;\n}\n\nconst useAudioRecorder = ({ \n  onRecordingComplete,\n  maxDuration = 60000 // 1 minute default\n}: UseAudioRecorderProps = {}) => {\n  const [state, setState] = useState<RecordingState>({\n    isRecording: false,\n    duration: 0,\n    error: null,\n    audioBlob: null,\n    audioUrl: null,\n  });\n  \n  const mediaRecorderRef = useRef<MediaRecorder | null>(null);\n  const streamRef = useRef<MediaStream | null>(null);\n  const timerRef = useRef<number | null>(null);\n  const startTimeRef = useRef<number>(0);\n  const audioContextRef = useRef<{ audioContext: AudioContext; analyser: AnalyserNode } | null>(null);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      stopRecording();\n      if (audioContextRef.current) {\n        audioContextRef.current.audioContext.close();\n      }\n      if (streamRef.current) {\n        streamRef.current.getTracks().forEach(track => track.stop());\n      }\n    };\n  }, []);\n\n  // Update duration while recording\n  useEffect(() => {\n    if (!state.isRecording) return;\n    \n    const updateDuration = () => {\n      const currentTime = Date.now();\n      const duration = Math.floor((currentTime - startTimeRef.current) / 1000);\n      \n      setState(prev => ({\n        ...prev,\n        duration,\n      }));\n      \n      if (duration * 1000 >= maxDuration) {\n        stopRecording();\n      } else {\n        timerRef.current = window.setTimeout(updateDuration, 100);\n      }\n    };\n    \n    timerRef.current = window.setTimeout(updateDuration, 100);\n    \n    return () => {\n      if (timerRef.current) {\n        clearTimeout(timerRef.current);\n      }\n    };\n  }, [state.isRecording, maxDuration]);\n\n  const startRecording = useCallback(async () => {\n    try {\n      // Reset state\n      setState({\n        isRecording: false,\n        duration: 0,\n        error: null,\n        audioBlob: null,\n        audioUrl: null,\n      });\n\n      // Get microphone access\n      const stream = await getMicrophoneAccess();\n      streamRef.current = stream;\n      \n      // Set up audio context for visualization\n      audioContextRef.current = createAudioContext(stream);\n      \n      // Create media recorder\n      const mediaRecorder = new MediaRecorder(stream);\n      mediaRecorderRef.current = mediaRecorder;\n      \n      const audioChunks: BlobPart[] = [];\n      \n      mediaRecorder.ondataavailable = (event) => {\n        if (event.data.size > 0) {\n          audioChunks.push(event.data);\n        }\n      };\n      \n      mediaRecorder.onstop = () => {\n        const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });\n        const audioUrl = URL.createObjectURL(audioBlob);\n        \n        setState(prev => ({\n          ...prev,\n          audioBlob,\n          audioUrl,\n          isRecording: false,\n        }));\n        \n        if (onRecordingComplete) {\n          onRecordingComplete(audioBlob);\n        }\n      };\n      \n      mediaRecorder.onerror = (event) => {\n        console.error('MediaRecorder error:', event);\n        setState(prev => ({\n          ...prev,\n          error: 'Error recording audio',\n          isRecording: false,\n        }));\n      };\n      \n      // Start recording\n      mediaRecorder.start();\n      startTimeRef.current = Date.now();\n      \n      setState(prev => ({\n        ...prev,\n        isRecording: true,\n        duration: 0,\n        error: null,\n      }));\n      \n    } catch (error) {\n      console.error('Error starting recording:', error);\n      setState(prev => ({\n        ...prev,\n        error: error instanceof Error ? error.message : 'Failed to start recording',\n        isRecording: false,\n      }));\n    }\n  }, [onRecordingComplete]);\n\n  const stopRecording = useCallback(() => {\n    if (mediaRecorderRef.current && state.isRecording) {\n      mediaRecorderRef.current.stop();\n      \n      // Stop all tracks in the stream\n      if (streamRef.current) {\n        streamRef.current.getTracks().forEach(track => track.stop());\n        streamRef.current = null;\n      }\n      \n      // Close audio context\n      if (audioContextRef.current) {\n        audioContextRef.current.audioContext.close();\n        audioContextRef.current = null;\n      }\n    }\n    \n    if (timerRef.current) {\n      clearTimeout(timerRef.current);\n      timerRef.current = null;\n    }\n  }, [state.isRecording]);\n\n  const reset = useCallback(() => {\n    stopRecording();\n    setState({\n      isRecording: false,\n      duration: 0,\n      error: null,\n      audioBlob: null,\n      audioUrl: null,\n    });\n  }, [stopRecording]);\n\n  const getAnalyserData = useCallback(() => {\n    if (!audioContextRef.current) return null;\n    \n    const { analyser } = audioContextRef.current;\n    const dataArray = new Uint8Array(analyser.frequencyBinCount);\n    analyser.getByteFrequencyData(dataArray);\n    \n    return {\n      data: Array.from(dataArray),\n      getFrequencyValue: (minHz: number, maxHz: number) => {\n        const sampleRate = audioContextRef.current?.audioContext.sampleRate || 44100;\n        const minIndex = Math.round((minHz / (sampleRate / 2)) * dataArray.length);\n        const maxIndex = Math.round((maxHz / (sampleRate / 2)) * dataArray.length);\n        \n        let sum = 0;\n        let count = 0;\n        \n        for (let i = minIndex; i <= maxIndex && i < dataArray.length; i++) {\n          sum += dataArray[i];\n          count++;\n        }\n        \n        return count > 0 ? sum / count : 0;\n      },\n      getVolume: () => {\n        let sum = 0;\n        dataArray.forEach(value => {\n          sum += value * value;\n        });\n        return Math.sqrt(sum / dataArray.length) / 255; // Normalize to 0-1\n      },\n    };\n  }, []);\n\n  return {\n    // State\n    isRecording: state.isRecording,\n    duration: state.duration,\n    formattedDuration: formatDuration(state.duration),\n    error: state.error,\n    audioBlob: state.audioBlob,\n    audioUrl: state.audioUrl,\n    \n    // Methods\n    startRecording,\n    stopRecording,\n    reset,\n    getAnalyserData,\n  };\n};\n\nexport default useAudioRecorder;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}