{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useRef, useEffect, useCallback } from 'react';\nimport { getMicrophoneAccess, createAudioContext, formatDuration } from '../utils/audioUtils';\nconst useAudioRecorder = ({\n  onRecordingComplete,\n  maxDuration = 60000 // 1 minute default\n} = {}) => {\n  _s();\n  const [state, setState] = useState({\n    isRecording: false,\n    duration: 0,\n    error: null,\n    audioBlob: null,\n    audioUrl: null\n  });\n  const mediaRecorderRef = useRef(null);\n  const streamRef = useRef(null);\n  const timerRef = useRef(null);\n  const startTimeRef = useRef(0);\n  const [audioContext, setAudioContext] = useState(null);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      stopRecording();\n      if (audioContext) {\n        audioContext.analyser.context.close();\n      }\n      if (streamRef.current) {\n        streamRef.current.getTracks().forEach(track => track.stop());\n      }\n    };\n  }, [audioContext]);\n\n  // Update duration while recording\n  useEffect(() => {\n    if (!state.isRecording) return;\n    const updateDuration = () => {\n      const currentTime = Date.now();\n      const duration = Math.floor((currentTime - startTimeRef.current) / 1000);\n      setState(prev => ({\n        ...prev,\n        duration\n      }));\n      if (duration * 1000 >= maxDuration) {\n        stopRecording();\n      } else {\n        timerRef.current = window.setTimeout(updateDuration, 100);\n      }\n    };\n    timerRef.current = window.setTimeout(updateDuration, 100);\n    return () => {\n      if (timerRef.current) {\n        clearTimeout(timerRef.current);\n      }\n    };\n  }, [state.isRecording, maxDuration]);\n  const startRecording = useCallback(async () => {\n    try {\n      // Reset state\n      setState({\n        isRecording: false,\n        duration: 0,\n        error: null,\n        audioBlob: null,\n        audioUrl: null\n      });\n\n      // Get microphone access\n      const stream = await getMicrophoneAccess();\n      streamRef.current = stream;\n\n      // Set up audio context for visualization\n      const audioContext = createAudioContext(stream);\n      setAudioContext(audioContext);\n\n      // Create media recorder\n      const mediaRecorder = new MediaRecorder(stream);\n      mediaRecorderRef.current = mediaRecorder;\n      const audioChunks = [];\n      mediaRecorder.ondataavailable = event => {\n        if (event.data.size > 0) {\n          audioChunks.push(event.data);\n        }\n      };\n      mediaRecorder.onstop = () => {\n        const audioBlob = new Blob(audioChunks, {\n          type: 'audio/wav'\n        });\n        const audioUrl = URL.createObjectURL(audioBlob);\n        setState(prev => ({\n          ...prev,\n          audioBlob,\n          audioUrl,\n          isRecording: false\n        }));\n        if (onRecordingComplete) {\n          onRecordingComplete(audioBlob);\n        }\n      };\n      mediaRecorder.onerror = event => {\n        console.error('MediaRecorder error:', event);\n        setState(prev => ({\n          ...prev,\n          error: 'Error recording audio',\n          isRecording: false\n        }));\n      };\n\n      // Start recording\n      mediaRecorder.start();\n      startTimeRef.current = Date.now();\n      setState(prev => ({\n        ...prev,\n        isRecording: true,\n        duration: 0,\n        error: null\n      }));\n    } catch (error) {\n      console.error('Error starting recording:', error);\n      setState(prev => ({\n        ...prev,\n        error: error instanceof Error ? error.message : 'Failed to start recording',\n        isRecording: false\n      }));\n    }\n  }, [onRecordingComplete]);\n  const stopRecording = useCallback(() => {\n    if (mediaRecorderRef.current && state.isRecording) {\n      mediaRecorderRef.current.stop();\n\n      // Stop all tracks in the stream\n      if (streamRef.current) {\n        streamRef.current.getTracks().forEach(track => track.stop());\n        streamRef.current = null;\n      }\n\n      // Close audio context\n      if (audioContext) {\n        audioContext.analyser.context.close();\n        setAudioContext(null);\n      }\n    }\n    if (timerRef.current) {\n      clearTimeout(timerRef.current);\n      timerRef.current = null;\n    }\n  }, [state.isRecording, audioContext]);\n  const reset = useCallback(() => {\n    stopRecording();\n    setState({\n      isRecording: false,\n      duration: 0,\n      error: null,\n      audioBlob: null,\n      audioUrl: null\n    });\n  }, [stopRecording]);\n  const getAnalyserData = useCallback(() => {\n    if (!audioContext) return null;\n    const {\n      analyser\n    } = audioContext;\n    const dataArray = new Uint8Array(analyser.frequencyBinCount);\n    analyser.getByteFrequencyData(dataArray);\n    return {\n      data: Array.from(dataArray),\n      getFrequencyValue: (minHz, maxHz) => {\n        const sampleRate = audioContext.analyser.context.sampleRate || 44100;\n        const minIndex = Math.round(minHz / (sampleRate / 2) * dataArray.length);\n        const maxIndex = Math.round(maxHz / (sampleRate / 2) * dataArray.length);\n        let sum = 0;\n        let count = 0;\n        for (let i = minIndex; i <= maxIndex && i < dataArray.length; i++) {\n          sum += dataArray[i];\n          count++;\n        }\n        return count > 0 ? sum / count : 0;\n      },\n      getVolume: () => {\n        let sum = 0;\n        dataArray.forEach(value => {\n          sum += value * value;\n        });\n        return Math.sqrt(sum / dataArray.length) / 255; // Normalize to 0-1\n      }\n    };\n  }, [audioContext]);\n  return {\n    // State\n    isRecording: state.isRecording,\n    duration: state.duration,\n    formattedDuration: formatDuration(state.duration),\n    error: state.error,\n    audioBlob: state.audioBlob,\n    audioUrl: state.audioUrl,\n    // Methods\n    startRecording,\n    stopRecording,\n    reset,\n    getAnalyserData\n  };\n};\n_s(useAudioRecorder, \"PtnXBXHAFxiTiIxO8+7rslgDHTE=\");\nexport default useAudioRecorder;","map":{"version":3,"names":["useState","useRef","useEffect","useCallback","getMicrophoneAccess","createAudioContext","formatDuration","useAudioRecorder","onRecordingComplete","maxDuration","_s","state","setState","isRecording","duration","error","audioBlob","audioUrl","mediaRecorderRef","streamRef","timerRef","startTimeRef","audioContext","setAudioContext","stopRecording","analyser","context","close","current","getTracks","forEach","track","stop","updateDuration","currentTime","Date","now","Math","floor","prev","window","setTimeout","clearTimeout","startRecording","stream","mediaRecorder","MediaRecorder","audioChunks","ondataavailable","event","data","size","push","onstop","Blob","type","URL","createObjectURL","onerror","console","start","Error","message","reset","getAnalyserData","dataArray","Uint8Array","frequencyBinCount","getByteFrequencyData","Array","from","getFrequencyValue","minHz","maxHz","sampleRate","minIndex","round","length","maxIndex","sum","count","i","getVolume","value","sqrt","formattedDuration"],"sources":["/Users/ganesharihanth/Desktop/App/doctor-patient-chat/client/src/hooks/useAudioRecorder.ts"],"sourcesContent":["import { useState, useRef, useEffect, useCallback } from 'react';\nimport { \n  getMicrophoneAccess, \n  recordAudio, \n  createAudioContext,\n  formatDuration\n} from '../utils/audioUtils';\n\ninterface UseAudioRecorderProps {\n  onRecordingComplete?: (audioBlob: Blob) => void;\n  maxDuration?: number; // in milliseconds\n}\n\ninterface RecordingState {\n  isRecording: boolean;\n  duration: number;\n  error: string | null;\n  audioBlob: Blob | null;\n  audioUrl: string | null;\n}\n\nconst useAudioRecorder = ({ \n  onRecordingComplete,\n  maxDuration = 60000 // 1 minute default\n}: UseAudioRecorderProps = {}) => {\n  const [state, setState] = useState<RecordingState>({\n    isRecording: false,\n    duration: 0,\n    error: null,\n    audioBlob: null,\n    audioUrl: null,\n  });\n  \n  const mediaRecorderRef = useRef<MediaRecorder | null>(null);\n  const streamRef = useRef<MediaStream | null>(null);\n  const timerRef = useRef<number | null>(null);\n  const startTimeRef = useRef<number>(0);\n  const [audioContext, setAudioContext] = useState<{ analyser: AnalyserNode } | null>(null);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      stopRecording();\n      if (audioContext) {\n        audioContext.analyser.context.close();\n      }\n      if (streamRef.current) {\n        streamRef.current.getTracks().forEach(track => track.stop());\n      }\n    };\n  }, [audioContext]);\n\n  // Update duration while recording\n  useEffect(() => {\n    if (!state.isRecording) return;\n    \n    const updateDuration = () => {\n      const currentTime = Date.now();\n      const duration = Math.floor((currentTime - startTimeRef.current) / 1000);\n      \n      setState(prev => ({\n        ...prev,\n        duration,\n      }));\n      \n      if (duration * 1000 >= maxDuration) {\n        stopRecording();\n      } else {\n        timerRef.current = window.setTimeout(updateDuration, 100);\n      }\n    };\n    \n    timerRef.current = window.setTimeout(updateDuration, 100);\n    \n    return () => {\n      if (timerRef.current) {\n        clearTimeout(timerRef.current);\n      }\n    };\n  }, [state.isRecording, maxDuration]);\n\n  const startRecording = useCallback(async () => {\n    try {\n      // Reset state\n      setState({\n        isRecording: false,\n        duration: 0,\n        error: null,\n        audioBlob: null,\n        audioUrl: null,\n      });\n\n      // Get microphone access\n      const stream = await getMicrophoneAccess();\n      streamRef.current = stream;\n      \n      // Set up audio context for visualization\n      const audioContext = createAudioContext(stream);\n      setAudioContext(audioContext);\n      \n      // Create media recorder\n      const mediaRecorder = new MediaRecorder(stream);\n      mediaRecorderRef.current = mediaRecorder;\n      \n      const audioChunks: BlobPart[] = [];\n      \n      mediaRecorder.ondataavailable = (event) => {\n        if (event.data.size > 0) {\n          audioChunks.push(event.data);\n        }\n      };\n      \n      mediaRecorder.onstop = () => {\n        const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });\n        const audioUrl = URL.createObjectURL(audioBlob);\n        \n        setState(prev => ({\n          ...prev,\n          audioBlob,\n          audioUrl,\n          isRecording: false,\n        }));\n        \n        if (onRecordingComplete) {\n          onRecordingComplete(audioBlob);\n        }\n      };\n      \n      mediaRecorder.onerror = (event) => {\n        console.error('MediaRecorder error:', event);\n        setState(prev => ({\n          ...prev,\n          error: 'Error recording audio',\n          isRecording: false,\n        }));\n      };\n      \n      // Start recording\n      mediaRecorder.start();\n      startTimeRef.current = Date.now();\n      \n      setState(prev => ({\n        ...prev,\n        isRecording: true,\n        duration: 0,\n        error: null,\n      }));\n      \n    } catch (error) {\n      console.error('Error starting recording:', error);\n      setState(prev => ({\n        ...prev,\n        error: error instanceof Error ? error.message : 'Failed to start recording',\n        isRecording: false,\n      }));\n    }\n  }, [onRecordingComplete]);\n\n  const stopRecording = useCallback(() => {\n    if (mediaRecorderRef.current && state.isRecording) {\n      mediaRecorderRef.current.stop();\n      \n      // Stop all tracks in the stream\n      if (streamRef.current) {\n        streamRef.current.getTracks().forEach(track => track.stop());\n        streamRef.current = null;\n      }\n      \n      // Close audio context\n      if (audioContext) {\n        audioContext.analyser.context.close();\n        setAudioContext(null);\n      }\n    }\n    \n    if (timerRef.current) {\n      clearTimeout(timerRef.current);\n      timerRef.current = null;\n    }\n  }, [state.isRecording, audioContext]);\n\n  const reset = useCallback(() => {\n    stopRecording();\n    setState({\n      isRecording: false,\n      duration: 0,\n      error: null,\n      audioBlob: null,\n      audioUrl: null,\n    });\n  }, [stopRecording]);\n\n  const getAnalyserData = useCallback(() => {\n    if (!audioContext) return null;\n    \n    const { analyser } = audioContext;\n    const dataArray = new Uint8Array(analyser.frequencyBinCount);\n    analyser.getByteFrequencyData(dataArray);\n    \n    return {\n      data: Array.from(dataArray),\n      getFrequencyValue: (minHz: number, maxHz: number) => {\n        const sampleRate = audioContext.analyser.context.sampleRate || 44100;\n        const minIndex = Math.round((minHz / (sampleRate / 2)) * dataArray.length);\n        const maxIndex = Math.round((maxHz / (sampleRate / 2)) * dataArray.length);\n        \n        let sum = 0;\n        let count = 0;\n        \n        for (let i = minIndex; i <= maxIndex && i < dataArray.length; i++) {\n          sum += dataArray[i];\n          count++;\n        }\n        \n        return count > 0 ? sum / count : 0;\n      },\n      getVolume: () => {\n        let sum = 0;\n        dataArray.forEach(value => {\n          sum += value * value;\n        });\n        return Math.sqrt(sum / dataArray.length) / 255; // Normalize to 0-1\n      },\n    };\n  }, [audioContext]);\n\n  return {\n    // State\n    isRecording: state.isRecording,\n    duration: state.duration,\n    formattedDuration: formatDuration(state.duration),\n    error: state.error,\n    audioBlob: state.audioBlob,\n    audioUrl: state.audioUrl,\n    \n    // Methods\n    startRecording,\n    stopRecording,\n    reset,\n    getAnalyserData,\n  };\n};\n\nexport default useAudioRecorder;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}