{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useRef, useEffect, useCallback } from 'react';\nimport { createAudioContext, formatDuration } from '../utils/audioUtils';\nexport const useAudioRecorder = ({\n  onRecordingComplete\n} = {}) => {\n  _s();\n  var _audioContextRef$curr, _audioContextRef$curr2;\n  const [isRecording, setIsRecording] = useState(false);\n  const [duration, setDuration] = useState(0);\n  const [audioBlob, setAudioBlob] = useState(null);\n  const [error, setError] = useState(null);\n  const mediaRecorderRef = useRef(null);\n  const audioContextRef = useRef(null);\n  const streamRef = useRef(null);\n  const timerRef = useRef(null);\n  const cleanup = useCallback(() => {\n    if (timerRef.current) {\n      clearInterval(timerRef.current);\n      timerRef.current = null;\n    }\n    if (mediaRecorderRef.current && mediaRecorderRef.current.state === 'recording') {\n      mediaRecorderRef.current.stop();\n    }\n    if (streamRef.current) {\n      streamRef.current.getTracks().forEach(track => track.stop());\n      streamRef.current = null;\n    }\n    if (audioContextRef.current) {\n      audioContextRef.current.audioContext.close();\n      audioContextRef.current = null;\n    }\n  }, []);\n  const reset = useCallback(() => {\n    cleanup();\n    setIsRecording(false);\n    setDuration(0);\n    setAudioBlob(null);\n    setError(null);\n  }, [cleanup]);\n  const startRecording = useCallback(async () => {\n    reset();\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({\n        audio: true\n      });\n      streamRef.current = stream;\n      audioContextRef.current = createAudioContext(stream);\n      const recorder = new MediaRecorder(stream);\n      mediaRecorderRef.current = recorder;\n      const chunks = [];\n      recorder.ondataavailable = event => {\n        if (event.data.size > 0) {\n          chunks.push(event.data);\n        }\n      };\n      recorder.onstop = () => {\n        const mimeType = MediaRecorder.isTypeSupported('audio/mp4') ? 'audio/mp4' : 'audio/webm';\n        const blob = new Blob(chunks, {\n          type: mimeType\n        });\n        setAudioBlob(blob);\n        if (onRecordingComplete) {\n          onRecordingComplete(blob);\n        }\n        cleanup();\n      };\n      recorder.onerror = event => {\n        const recorderError = event.error;\n        setError(`Recording error: ${recorderError.name} - ${recorderError.message}`);\n        cleanup();\n      };\n      recorder.start();\n      setIsRecording(true);\n      timerRef.current = setInterval(() => {\n        setDuration(prev => prev + 1);\n      }, 1000);\n    } catch (err) {\n      setError('Could not start recording. Please allow microphone access.');\n      console.error('Error starting recording:', err);\n      cleanup();\n    }\n  }, [reset, onRecordingComplete, cleanup]);\n  const stopRecording = useCallback(() => {\n    if (mediaRecorderRef.current && mediaRecorderRef.current.state === 'recording') {\n      mediaRecorderRef.current.stop();\n      setIsRecording(false);\n      if (timerRef.current) {\n        clearInterval(timerRef.current);\n      }\n    }\n  }, []);\n  useEffect(() => {\n    return cleanup;\n  }, [cleanup]);\n  return {\n    isRecording,\n    duration,\n    formattedDuration: formatDuration(duration),\n    audioBlob,\n    error,\n    analyser: (_audioContextRef$curr = (_audioContextRef$curr2 = audioContextRef.current) === null || _audioContextRef$curr2 === void 0 ? void 0 : _audioContextRef$curr2.analyser) !== null && _audioContextRef$curr !== void 0 ? _audioContextRef$curr : null,\n    startRecording,\n    stopRecording,\n    reset\n  };\n};\n_s(useAudioRecorder, \"mAYMv/9xCa5XvERgFgt2NRSKtuI=\");","map":{"version":3,"names":["useState","useRef","useEffect","useCallback","createAudioContext","formatDuration","useAudioRecorder","onRecordingComplete","_s","_audioContextRef$curr","_audioContextRef$curr2","isRecording","setIsRecording","duration","setDuration","audioBlob","setAudioBlob","error","setError","mediaRecorderRef","audioContextRef","streamRef","timerRef","cleanup","current","clearInterval","state","stop","getTracks","forEach","track","audioContext","close","reset","startRecording","stream","navigator","mediaDevices","getUserMedia","audio","recorder","MediaRecorder","chunks","ondataavailable","event","data","size","push","onstop","mimeType","isTypeSupported","blob","Blob","type","onerror","recorderError","name","message","start","setInterval","prev","err","console","stopRecording","formattedDuration","analyser"],"sources":["/Users/ganesharihanth/Desktop/App/doctor-patient-chat/client/src/hooks/useAudioRecorder.ts"],"sourcesContent":["import { useState, useRef, useEffect, useCallback } from 'react';\nimport { createAudioContext, formatDuration } from '../utils/audioUtils';\n\ninterface UseAudioRecorderProps {\n  onRecordingComplete?: (blob: Blob) => void;\n}\n\nexport const useAudioRecorder = ({ onRecordingComplete }: UseAudioRecorderProps = {}) => {\n  const [isRecording, setIsRecording] = useState(false);\n  const [duration, setDuration] = useState(0);\n  const [audioBlob, setAudioBlob] = useState<Blob | null>(null);\n  const [error, setError] = useState<string | null>(null);\n\n  const mediaRecorderRef = useRef<MediaRecorder | null>(null);\n  const audioContextRef = useRef<{ audioContext: AudioContext; analyser: AnalyserNode } | null>(null);\n  const streamRef = useRef<MediaStream | null>(null);\n  const timerRef = useRef<NodeJS.Timeout | null>(null);\n\n  const cleanup = useCallback(() => {\n    if (timerRef.current) {\n      clearInterval(timerRef.current);\n      timerRef.current = null;\n    }\n    if (mediaRecorderRef.current && mediaRecorderRef.current.state === 'recording') {\n      mediaRecorderRef.current.stop();\n    }\n    if (streamRef.current) {\n      streamRef.current.getTracks().forEach((track) => track.stop());\n      streamRef.current = null;\n    }\n    if (audioContextRef.current) {\n      audioContextRef.current.audioContext.close();\n      audioContextRef.current = null;\n    }\n  }, []);\n\n  const reset = useCallback(() => {\n    cleanup();\n    setIsRecording(false);\n    setDuration(0);\n    setAudioBlob(null);\n    setError(null);\n  }, [cleanup]);\n\n  const startRecording = useCallback(async () => {\n    reset();\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n      streamRef.current = stream;\n      audioContextRef.current = createAudioContext(stream);\n      \n      const recorder = new MediaRecorder(stream);\n      mediaRecorderRef.current = recorder;\n\n      const chunks: Blob[] = [];\n      recorder.ondataavailable = (event) => {\n        if (event.data.size > 0) {\n          chunks.push(event.data);\n        }\n      };\n\n      recorder.onstop = () => {\n                const mimeType = MediaRecorder.isTypeSupported('audio/mp4') \n          ? 'audio/mp4' \n          : 'audio/webm';\n        const blob = new Blob(chunks, { type: mimeType });\n        setAudioBlob(blob);\n        if (onRecordingComplete) {\n          onRecordingComplete(blob);\n        }\n        cleanup();\n      };\n\n      recorder.onerror = (event) => {\n        const recorderError = (event as any).error as DOMException;\n        setError(`Recording error: ${recorderError.name} - ${recorderError.message}`);\n        cleanup();\n      };\n\n      recorder.start();\n      setIsRecording(true);\n      timerRef.current = setInterval(() => {\n        setDuration((prev) => prev + 1);\n      }, 1000);\n\n    } catch (err) {\n      setError('Could not start recording. Please allow microphone access.');\n      console.error('Error starting recording:', err);\n      cleanup();\n    }\n  }, [reset, onRecordingComplete, cleanup]);\n\n  const stopRecording = useCallback(() => {\n    if (mediaRecorderRef.current && mediaRecorderRef.current.state === 'recording') {\n      mediaRecorderRef.current.stop();\n      setIsRecording(false);\n      if (timerRef.current) {\n        clearInterval(timerRef.current);\n      }\n    }\n  }, []);\n\n  useEffect(() => {\n    return cleanup;\n  }, [cleanup]);\n\n  return {\n    isRecording,\n    duration,\n    formattedDuration: formatDuration(duration),\n    audioBlob,\n    error,\n    analyser: audioContextRef.current?.analyser ?? null,\n    startRecording,\n    stopRecording,\n    reset,\n  };\n};\n"],"mappings":";AAAA,SAASA,QAAQ,EAAEC,MAAM,EAAEC,SAAS,EAAEC,WAAW,QAAQ,OAAO;AAChE,SAASC,kBAAkB,EAAEC,cAAc,QAAQ,qBAAqB;AAMxE,OAAO,MAAMC,gBAAgB,GAAGA,CAAC;EAAEC;AAA2C,CAAC,GAAG,CAAC,CAAC,KAAK;EAAAC,EAAA;EAAA,IAAAC,qBAAA,EAAAC,sBAAA;EACvF,MAAM,CAACC,WAAW,EAAEC,cAAc,CAAC,GAAGZ,QAAQ,CAAC,KAAK,CAAC;EACrD,MAAM,CAACa,QAAQ,EAAEC,WAAW,CAAC,GAAGd,QAAQ,CAAC,CAAC,CAAC;EAC3C,MAAM,CAACe,SAAS,EAAEC,YAAY,CAAC,GAAGhB,QAAQ,CAAc,IAAI,CAAC;EAC7D,MAAM,CAACiB,KAAK,EAAEC,QAAQ,CAAC,GAAGlB,QAAQ,CAAgB,IAAI,CAAC;EAEvD,MAAMmB,gBAAgB,GAAGlB,MAAM,CAAuB,IAAI,CAAC;EAC3D,MAAMmB,eAAe,GAAGnB,MAAM,CAAgE,IAAI,CAAC;EACnG,MAAMoB,SAAS,GAAGpB,MAAM,CAAqB,IAAI,CAAC;EAClD,MAAMqB,QAAQ,GAAGrB,MAAM,CAAwB,IAAI,CAAC;EAEpD,MAAMsB,OAAO,GAAGpB,WAAW,CAAC,MAAM;IAChC,IAAImB,QAAQ,CAACE,OAAO,EAAE;MACpBC,aAAa,CAACH,QAAQ,CAACE,OAAO,CAAC;MAC/BF,QAAQ,CAACE,OAAO,GAAG,IAAI;IACzB;IACA,IAAIL,gBAAgB,CAACK,OAAO,IAAIL,gBAAgB,CAACK,OAAO,CAACE,KAAK,KAAK,WAAW,EAAE;MAC9EP,gBAAgB,CAACK,OAAO,CAACG,IAAI,CAAC,CAAC;IACjC;IACA,IAAIN,SAAS,CAACG,OAAO,EAAE;MACrBH,SAAS,CAACG,OAAO,CAACI,SAAS,CAAC,CAAC,CAACC,OAAO,CAAEC,KAAK,IAAKA,KAAK,CAACH,IAAI,CAAC,CAAC,CAAC;MAC9DN,SAAS,CAACG,OAAO,GAAG,IAAI;IAC1B;IACA,IAAIJ,eAAe,CAACI,OAAO,EAAE;MAC3BJ,eAAe,CAACI,OAAO,CAACO,YAAY,CAACC,KAAK,CAAC,CAAC;MAC5CZ,eAAe,CAACI,OAAO,GAAG,IAAI;IAChC;EACF,CAAC,EAAE,EAAE,CAAC;EAEN,MAAMS,KAAK,GAAG9B,WAAW,CAAC,MAAM;IAC9BoB,OAAO,CAAC,CAAC;IACTX,cAAc,CAAC,KAAK,CAAC;IACrBE,WAAW,CAAC,CAAC,CAAC;IACdE,YAAY,CAAC,IAAI,CAAC;IAClBE,QAAQ,CAAC,IAAI,CAAC;EAChB,CAAC,EAAE,CAACK,OAAO,CAAC,CAAC;EAEb,MAAMW,cAAc,GAAG/B,WAAW,CAAC,YAAY;IAC7C8B,KAAK,CAAC,CAAC;IACP,IAAI;MACF,MAAME,MAAM,GAAG,MAAMC,SAAS,CAACC,YAAY,CAACC,YAAY,CAAC;QAAEC,KAAK,EAAE;MAAK,CAAC,CAAC;MACzElB,SAAS,CAACG,OAAO,GAAGW,MAAM;MAC1Bf,eAAe,CAACI,OAAO,GAAGpB,kBAAkB,CAAC+B,MAAM,CAAC;MAEpD,MAAMK,QAAQ,GAAG,IAAIC,aAAa,CAACN,MAAM,CAAC;MAC1ChB,gBAAgB,CAACK,OAAO,GAAGgB,QAAQ;MAEnC,MAAME,MAAc,GAAG,EAAE;MACzBF,QAAQ,CAACG,eAAe,GAAIC,KAAK,IAAK;QACpC,IAAIA,KAAK,CAACC,IAAI,CAACC,IAAI,GAAG,CAAC,EAAE;UACvBJ,MAAM,CAACK,IAAI,CAACH,KAAK,CAACC,IAAI,CAAC;QACzB;MACF,CAAC;MAEDL,QAAQ,CAACQ,MAAM,GAAG,MAAM;QACd,MAAMC,QAAQ,GAAGR,aAAa,CAACS,eAAe,CAAC,WAAW,CAAC,GAC/D,WAAW,GACX,YAAY;QAChB,MAAMC,IAAI,GAAG,IAAIC,IAAI,CAACV,MAAM,EAAE;UAAEW,IAAI,EAAEJ;QAAS,CAAC,CAAC;QACjDjC,YAAY,CAACmC,IAAI,CAAC;QAClB,IAAI5C,mBAAmB,EAAE;UACvBA,mBAAmB,CAAC4C,IAAI,CAAC;QAC3B;QACA5B,OAAO,CAAC,CAAC;MACX,CAAC;MAEDiB,QAAQ,CAACc,OAAO,GAAIV,KAAK,IAAK;QAC5B,MAAMW,aAAa,GAAIX,KAAK,CAAS3B,KAAqB;QAC1DC,QAAQ,CAAC,oBAAoBqC,aAAa,CAACC,IAAI,MAAMD,aAAa,CAACE,OAAO,EAAE,CAAC;QAC7ElC,OAAO,CAAC,CAAC;MACX,CAAC;MAEDiB,QAAQ,CAACkB,KAAK,CAAC,CAAC;MAChB9C,cAAc,CAAC,IAAI,CAAC;MACpBU,QAAQ,CAACE,OAAO,GAAGmC,WAAW,CAAC,MAAM;QACnC7C,WAAW,CAAE8C,IAAI,IAAKA,IAAI,GAAG,CAAC,CAAC;MACjC,CAAC,EAAE,IAAI,CAAC;IAEV,CAAC,CAAC,OAAOC,GAAG,EAAE;MACZ3C,QAAQ,CAAC,4DAA4D,CAAC;MACtE4C,OAAO,CAAC7C,KAAK,CAAC,2BAA2B,EAAE4C,GAAG,CAAC;MAC/CtC,OAAO,CAAC,CAAC;IACX;EACF,CAAC,EAAE,CAACU,KAAK,EAAE1B,mBAAmB,EAAEgB,OAAO,CAAC,CAAC;EAEzC,MAAMwC,aAAa,GAAG5D,WAAW,CAAC,MAAM;IACtC,IAAIgB,gBAAgB,CAACK,OAAO,IAAIL,gBAAgB,CAACK,OAAO,CAACE,KAAK,KAAK,WAAW,EAAE;MAC9EP,gBAAgB,CAACK,OAAO,CAACG,IAAI,CAAC,CAAC;MAC/Bf,cAAc,CAAC,KAAK,CAAC;MACrB,IAAIU,QAAQ,CAACE,OAAO,EAAE;QACpBC,aAAa,CAACH,QAAQ,CAACE,OAAO,CAAC;MACjC;IACF;EACF,CAAC,EAAE,EAAE,CAAC;EAENtB,SAAS,CAAC,MAAM;IACd,OAAOqB,OAAO;EAChB,CAAC,EAAE,CAACA,OAAO,CAAC,CAAC;EAEb,OAAO;IACLZ,WAAW;IACXE,QAAQ;IACRmD,iBAAiB,EAAE3D,cAAc,CAACQ,QAAQ,CAAC;IAC3CE,SAAS;IACTE,KAAK;IACLgD,QAAQ,GAAAxD,qBAAA,IAAAC,sBAAA,GAAEU,eAAe,CAACI,OAAO,cAAAd,sBAAA,uBAAvBA,sBAAA,CAAyBuD,QAAQ,cAAAxD,qBAAA,cAAAA,qBAAA,GAAI,IAAI;IACnDyB,cAAc;IACd6B,aAAa;IACb9B;EACF,CAAC;AACH,CAAC;AAACzB,EAAA,CA9GWF,gBAAgB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}